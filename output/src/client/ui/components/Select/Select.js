// Generated by Melange

import SelectCss from "./Select.css";
import * as Belt__Belt_Array from "melange.belt/belt_Array.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Components__InputLabel from "../InputLabel/InputLabel.js";
import * as Css from "../../../css/Css.js";
import * as Curry from "melange.js/curry.js";
import * as Hooks__Hooks_ClickAway from "../../../hooks/Hooks_ClickAway.js";
import * as Images__Icons from "../../../images/Icons.js";
import * as Stdlib__Option from "melange/option.js";
import * as React from "react";
import * as JsxRuntime from "react/jsx-runtime";

const css = SelectCss;

function make(disabledOpt, value, text, param) {
  const disabled = disabledOpt !== undefined ? disabledOpt : false;
  return {
    value: value,
    text: text,
    disabled: disabled
  };
}

const SelectOption = {
  make: make
};

function scrollElementIntoView(listbox, el) {
  const listbox$1 = listbox.current;
  const el$1 = el.current;
  if (listbox$1 == null) {
    return;
  }
  if (el$1 == null) {
    return;
  }
  if (listbox$1.scrollHeight <= listbox$1.clientHeight) {
    return;
  }
  const scrollBottom = listbox$1.clientHeight + listbox$1.scrollTop | 0;
  const elementBottom = el$1.offsetTop + el$1.offsetHeight | 0;
  if (elementBottom > scrollBottom) {
    listbox$1.scrollTop = elementBottom - listbox$1.clientHeight | 0;
    return;
  } else if (el$1.offsetTop < listbox$1.scrollTop) {
    listbox$1.scrollTop = el$1.offsetTop;
    return;
  } else {
    return;
  }
}

const Helpers = {
  scrollElementIntoView: scrollElementIntoView
};

function Select$Single(Props) {
  let classNameOpt = Props.className;
  let disabledOpt = Props.disabled;
  let label = Props.label;
  let name = Props.name;
  let options = Props.options;
  let value = Props.value;
  let onChange = Props.onChange;
  const className = classNameOpt !== undefined ? classNameOpt : "";
  const disabled = disabledOpt !== undefined ? disabledOpt : false;
  const buttonRef = React.createRef();
  const listboxRef = React.createRef();
  const focusedEl = React.createRef();
  const match = React.useState(function () {
    return "";
  });
  const setKeysSoFar = match[1];
  const keysSoFar = match[0];
  const match$1 = React.useState(function () {
    
  });
  const setFocusedOption = match$1[1];
  const focusedOption = match$1[0];
  const match$2 = React.useState(function () {
    
  });
  const setIsOpen = match$2[1];
  const isOpen = match$2[0];
  Hooks__Hooks_ClickAway.useClickAway({
    hd: listboxRef,
    tl: {
      hd: buttonRef,
      tl: /* [] */ 0
    }
  }, (function (_e) {
    Curry._1(setIsOpen, (function (param) {
      
    }));
  }));
  React.useEffect((function () {
    scrollElementIntoView(listboxRef, focusedEl);
  }), [
    listboxRef,
    focusedEl
  ]);
  React.useEffect((function () {
    if (isOpen !== undefined) {
      if (isOpen) {
        const listbox = listboxRef.current;
        if (!(listbox == null)) {
          listbox.focus();
        }
        
      } else {
        Stdlib__Option.map((function (button) {
          button.focus();
        }), Caml_option.nullable_to_opt(buttonRef.current));
      }
    }
    
  }), [
    isOpen,
    buttonRef,
    listboxRef
  ]);
  React.useEffect((function () {
    const timeoutId = setTimeout((function (param) {
      Curry._1(setKeysSoFar, (function (param) {
        return "";
      }));
    }), 500);
    return (function (param) {
      clearTimeout(timeoutId);
    });
  }), [
    keysSoFar,
    setKeysSoFar
  ]);
  const handleChange = function (option) {
    if (!disabled && !option.disabled) {
      Curry._1(onChange, option.value);
      return Curry._1(setIsOpen, (function (param) {
        return false;
      }));
    }
    
  };
  const findMatchInRange = function (startIndex, endIndex) {
    const foundIndex = {
      contents: 0
    };
    const foundOption = options.find(function (option, index) {
      if (index >= startIndex && index < endIndex) {
        foundIndex.contents = index;
        return option.text.toUpperCase().indexOf(keysSoFar.toUpperCase(), undefined) === 0;
      } else {
        return false;
      }
    });
    return [
      foundIndex.contents,
      foundOption === undefined ? undefined : Caml_option.some(foundOption)
    ];
  };
  const focusFirstItem = function (param) {
    const option = Belt__Belt_Array.get(options, 0);
    if (option !== undefined) {
      return Curry._1(setFocusedOption, (function (param) {
        return [
          0,
          option
        ];
      }));
    }
    
  };
  const findItemToFocus = function (key) {
    let searchIndex;
    if (keysSoFar === "" && focusedOption !== undefined) {
      const focusedOption$1 = focusedOption[1];
      const index = options.findIndex(function (option) {
        return option.text === focusedOption$1.text;
      });
      searchIndex = index === -1 ? 0 : index;
    } else {
      searchIndex = 0;
    }
    Curry._1(setKeysSoFar, (function (currentKeys) {
      return currentKeys + key;
    }));
    const nextMatch = findMatchInRange(searchIndex + 1 | 0, options.length);
    if (nextMatch[1] !== undefined) {
      return nextMatch;
    } else {
      return findMatchInRange(0, searchIndex);
    }
  };
  const handleListKeyDown = function (e) {
    const key = e.key;
    if (focusedOption === undefined) {
      return;
    }
    const index = focusedOption[0];
    let exit = 0;
    switch (key) {
      case "ArrowDown" :
      case "Down" :
        exit = 4;
        break;
      case "End" :
        e.preventDefault();
        const len = options.length;
        const option = Belt__Belt_Array.get(options, len - 1 | 0);
        if (option !== undefined) {
          return Curry._1(setFocusedOption, (function (param) {
            return [
              len - 1 | 0,
              option
            ];
          }));
        } else {
          return;
        }
      case " " :
      case "Enter" :
        exit = 2;
        break;
      case "Esc" :
      case "Escape" :
        exit = 1;
        break;
      case "Home" :
        e.preventDefault();
        return focusFirstItem(undefined);
      case "ArrowUp" :
      case "Up" :
        exit = 3;
        break;
      default:
        const itemToFocus = findItemToFocus(key);
        const item = itemToFocus[1];
        if (item === undefined) {
          return;
        }
        const index$1 = itemToFocus[0];
        return Curry._1(setFocusedOption, (function (param) {
          return [
            index$1,
            item
          ];
        }));
    }
    switch (exit) {
      case 1 :
        e.preventDefault();
        return Curry._1(setIsOpen, (function (param) {
          return false;
        }));
      case 2 :
        e.preventDefault();
        Curry._1(setIsOpen, (function (param) {
          return false;
        }));
        return handleChange(focusedOption[1]);
      case 3 :
        e.preventDefault();
        const prevItem = Belt__Belt_Array.get(options, index - 1 | 0);
        if (prevItem !== undefined) {
          return Curry._1(setFocusedOption, (function (param) {
            return [
              index - 1 | 0,
              prevItem
            ];
          }));
        } else {
          return;
        }
      case 4 :
        e.preventDefault();
        const nextItem = Belt__Belt_Array.get(options, index + 1 | 0);
        if (nextItem !== undefined) {
          return Curry._1(setFocusedOption, (function (param) {
            return [
              index + 1 | 0,
              nextItem
            ];
          }));
        } else {
          return;
        }
    }
  };
  const handleButtonKeyUp = function (e) {
    const match = e.key;
    switch (match) {
      case "ArrowDown" :
      case "ArrowUp" :
      case "Down" :
      case "Up" :
        break;
      default:
        return;
    }
    e.preventDefault();
    Curry._1(setIsOpen, (function (param) {
      return true;
    }));
    handleListKeyDown(e);
  };
  const handleListFocus = function (_e) {
    if (focusedOption !== undefined) {
      return;
    } else {
      return focusFirstItem(undefined);
    }
  };
  let tmp;
  if (value !== undefined) {
    const value$1 = Caml_option.valFromOption(value);
    tmp = Stdlib__Option.value(Stdlib__Option.map((function (opt) {
      return opt.text;
    }), Caml_option.undefined_to_opt(options.find(function (opt) {
      return Caml_obj.caml_equal(opt.value, value$1);
    }))), "Nothing selected...");
  } else {
    tmp = "Nothing selected...";
  }
  return JsxRuntime.jsxs("div", {
    children: [
      label !== undefined ? JsxRuntime.jsx(Components__InputLabel.make, {
          className: "Select-label",
          text: label,
          htmlFor: name
        }) : null,
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            ref: buttonRef,
            children: tmp,
            "aria-expanded": Stdlib__Option.value(isOpen, false) ? true : false,
            "aria-labelledby": "Select-label Select-toggle",
            className: "Select-toggle",
            id: "Select-toggle",
            disabled: disabled,
            type: "button",
            onKeyUp: handleButtonKeyUp,
            onClick: (function (_e) {
              Curry._1(setIsOpen, (function (isOpen) {
                if (isOpen !== undefined) {
                  return !isOpen;
                } else {
                  return true;
                }
              }));
            })
          }),
          JsxRuntime.jsx(Images__Icons.ChevronDown.make, {
            className: "Select-arrow"
          })
        ],
        className: "Select-inputWrapper"
      }),
      JsxRuntime.jsx("div", {
        children: JsxRuntime.jsx("ul", {
          ref: listboxRef,
          children: options.map(function (option, index) {
            const id = name + ("-" + option.text);
            const isFocused = Stdlib__Option.value(Stdlib__Option.map((function (param) {
              return param[1].text === option.text;
            }), focusedOption), false);
            const isSelected = value !== undefined ? Caml_obj.caml_equal(Caml_option.valFromOption(value), option.value) : false;
            const isDisabled = option.disabled;
            const Key = option.text;
            return JsxRuntime.jsxs("li", {
              ref: (function (el) {
                if (isFocused) {
                  focusedEl.current = el;
                  return;
                }
                
              }),
              children: [
                option.text,
                isSelected ? JsxRuntime.jsx(Images__Icons.Checkmark.make, {
                    className: "Select-optionIcon"
                  }) : null
              ],
              "aria-selected": isSelected ? true : false,
              className: Css.merge([
                "Select-option",
                isFocused ? "is-focused" : "",
                isSelected ? "is-selected" : "",
                isDisabled ? "is-disabled" : ""
              ]),
              id: id,
              role: "option",
              onClick: (function (param) {
                handleChange(option);
              }),
              onMouseOver: (function (param) {
                Curry._1(setFocusedOption, (function (param) {
                  return [
                    index,
                    option
                  ];
                }));
              })
            }, Key);
          }),
          "aria-activedescendant": Stdlib__Option.value(Stdlib__Option.map((function (param) {
            return name + ("-" + param[1].text);
          }), focusedOption), ""),
          "aria-labelledby": "Select-label",
          className: Css.merge([
            "Select-optionList",
            Stdlib__Option.value(isOpen, false) ? "" : "is-hidden"
          ]),
          role: "listbox",
          tabIndex: -1,
          onKeyDown: handleListKeyDown,
          onFocus: handleListFocus
        }),
        className: "Select-optionListWrapper"
      })
    ],
    className: Css.merge([
      "Select",
      disabled ? "is-disabled" : "",
      Stdlib__Option.value(isOpen, false) ? "is-open" : "",
      className
    ])
  });
}

const Single = {
  make: Select$Single
};

function Select$Multi(Props) {
  let classNameOpt = Props.className;
  let disabledOpt = Props.disabled;
  let label = Props.label;
  let name = Props.name;
  let options = Props.options;
  let minItems = Props.minItems;
  let maxItems = Props.maxItems;
  let value = Props.value;
  let onChange = Props.onChange;
  let selectedTextOpt = Props.selectedText;
  const className = classNameOpt !== undefined ? classNameOpt : "";
  const disabled = disabledOpt !== undefined ? disabledOpt : false;
  const selectedText = selectedTextOpt !== undefined ? selectedTextOpt : (function (param) {
      return "selected item(s)";
    });
  const buttonRef = React.createRef();
  const listboxRef = React.createRef();
  const focusedEl = React.createRef();
  const match = React.useState(function () {
    return "";
  });
  const setKeysSoFar = match[1];
  const keysSoFar = match[0];
  const match$1 = React.useState(function () {
    
  });
  const setFocusedOption = match$1[1];
  const focusedOption = match$1[0];
  const match$2 = React.useState(function () {
    
  });
  const setIsOpen = match$2[1];
  const isOpen = match$2[0];
  Hooks__Hooks_ClickAway.useClickAway({
    hd: listboxRef,
    tl: {
      hd: buttonRef,
      tl: /* [] */ 0
    }
  }, (function (_e) {
    Curry._1(setIsOpen, (function (param) {
      
    }));
  }));
  React.useEffect((function () {
    scrollElementIntoView(listboxRef, focusedEl);
  }), [
    listboxRef,
    focusedEl
  ]);
  React.useEffect((function () {
    if (isOpen !== undefined) {
      if (isOpen) {
        const listbox = listboxRef.current;
        if (!(listbox == null)) {
          listbox.focus();
        }
        
      } else {
        Stdlib__Option.iter((function (button) {
          button.focus();
        }), Caml_option.nullable_to_opt(buttonRef.current));
      }
    }
    
  }), [
    isOpen,
    buttonRef,
    listboxRef
  ]);
  React.useEffect((function () {
    const timeoutId = setTimeout((function (param) {
      Curry._1(setKeysSoFar, (function (param) {
        return "";
      }));
    }), 500);
    return (function (param) {
      clearTimeout(timeoutId);
    });
  }), [
    keysSoFar,
    setKeysSoFar
  ]);
  const handleChange = function (option) {
    if (!(!disabled && !option.disabled)) {
      return;
    }
    if (value.includes(option.value)) {
      const minValuesReached = minItems !== undefined ? value.length <= minItems : false;
      if (!minValuesReached) {
        return Curry._1(onChange, value.filter(function (value) {
          return Caml_obj.caml_notequal(value, option.value);
        }));
      } else {
        return;
      }
    }
    const maxValuesReached = maxItems !== undefined ? value.length >= maxItems : false;
    if (!maxValuesReached) {
      return Curry._1(onChange, value.concat([option.value]));
    }
    
  };
  const findMatchInRange = function (startIndex, endIndex) {
    const foundIndex = {
      contents: 0
    };
    const foundOption = options.find(function (option, index) {
      if (index >= startIndex && index < endIndex) {
        foundIndex.contents = index;
        return option.text.toUpperCase().startsWith(keysSoFar.toUpperCase(), undefined);
      } else {
        return false;
      }
    });
    return [
      foundIndex.contents,
      foundOption === undefined ? undefined : Caml_option.some(foundOption)
    ];
  };
  const focusFirstItem = function (param) {
    const option = Belt__Belt_Array.get(options, 0);
    if (option !== undefined) {
      return Curry._1(setFocusedOption, (function (param) {
        return [
          0,
          option
        ];
      }));
    }
    
  };
  const findItemToFocus = function (key) {
    let searchIndex;
    if (keysSoFar === "" && focusedOption !== undefined) {
      const focusedOption$1 = focusedOption[1];
      const index = options.findIndex(function (option) {
        return option.text === focusedOption$1.text;
      });
      searchIndex = index === -1 ? 0 : index;
    } else {
      searchIndex = 0;
    }
    Curry._1(setKeysSoFar, (function (currentKeys) {
      return currentKeys + key;
    }));
    const nextMatch = findMatchInRange(searchIndex + 1 | 0, options.length);
    if (nextMatch[1] !== undefined) {
      return nextMatch;
    } else {
      return findMatchInRange(0, searchIndex);
    }
  };
  const handleListKeyDown = function (e) {
    const key = e.key;
    if (focusedOption === undefined) {
      return;
    }
    const focusedOption$1 = focusedOption[1];
    const index = focusedOption[0];
    let exit = 0;
    switch (key) {
      case "ArrowDown" :
      case "Down" :
        exit = 3;
        break;
      case "End" :
        e.preventDefault();
        const len = options.length;
        const option = Belt__Belt_Array.get(options, len - 1 | 0);
        if (option !== undefined) {
          return Curry._1(setFocusedOption, (function (param) {
            return [
              len - 1 | 0,
              option
            ];
          }));
        } else {
          return;
        }
      case " " :
      case "Enter" :
        e.preventDefault();
        return handleChange(focusedOption$1);
      case "Esc" :
      case "Escape" :
        exit = 1;
        break;
      case "Home" :
        e.preventDefault();
        return focusFirstItem(undefined);
      case "ArrowUp" :
      case "Up" :
        exit = 2;
        break;
      default:
        const itemToFocus = findItemToFocus(key);
        const item = itemToFocus[1];
        if (item === undefined) {
          return;
        }
        const index$1 = itemToFocus[0];
        return Curry._1(setFocusedOption, (function (param) {
          return [
            index$1,
            item
          ];
        }));
    }
    switch (exit) {
      case 1 :
        e.preventDefault();
        return Curry._1(setIsOpen, (function (param) {
          return false;
        }));
      case 2 :
        e.preventDefault();
        const prevItem = Belt__Belt_Array.get(options, index - 1 | 0);
        if (prevItem !== undefined) {
          return Curry._1(setFocusedOption, (function (param) {
            return [
              index - 1 | 0,
              prevItem
            ];
          }));
        } else {
          return;
        }
      case 3 :
        e.preventDefault();
        const nextItem = Belt__Belt_Array.get(options, index + 1 | 0);
        if (nextItem !== undefined) {
          return Curry._1(setFocusedOption, (function (param) {
            return [
              index + 1 | 0,
              nextItem
            ];
          }));
        } else {
          return;
        }
    }
  };
  const handleButtonKeyUp = function (e) {
    const key = e.key;
    switch (key) {
      case "ArrowDown" :
      case "ArrowUp" :
      case "Down" :
      case "Up" :
        break;
      default:
        return;
    }
    e.preventDefault();
    Curry._1(setIsOpen, (function (param) {
      return true;
    }));
    handleListKeyDown(e);
  };
  const handleListFocus = function (_e) {
    if (focusedOption !== undefined) {
      return;
    } else {
      return focusFirstItem(undefined);
    }
  };
  return JsxRuntime.jsxs("div", {
    children: [
      label !== undefined ? JsxRuntime.jsx(Components__InputLabel.make, {
          className: "Select-label",
          text: label,
          htmlFor: name
        }) : null,
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            ref: buttonRef,
            children: Curry._1(selectedText, value),
            "aria-expanded": Stdlib__Option.value(isOpen, false) ? true : false,
            "aria-labelledby": "Select-label Select-toggle",
            className: "Select-toggle",
            id: "Select-toggle",
            disabled: disabled,
            type: "button",
            onKeyUp: handleButtonKeyUp,
            onClick: (function (_e) {
              Curry._1(setIsOpen, (function (isOpen) {
                if (isOpen !== undefined) {
                  return !isOpen;
                } else {
                  return true;
                }
              }));
            })
          }),
          JsxRuntime.jsx(Images__Icons.ChevronDown.make, {
            className: "Select-arrow"
          })
        ],
        className: "Select-inputWrapper"
      }),
      JsxRuntime.jsx("div", {
        children: JsxRuntime.jsx("ul", {
          ref: listboxRef,
          children: options.map(function (option, index) {
            const id = name + ("-" + option.text);
            const isFocused = Stdlib__Option.value(Stdlib__Option.map((function (param) {
              return param[1].text === option.text;
            }), focusedOption), false);
            const isSelected = value.includes(option.value);
            const isDisabled = option.disabled;
            const Key = option.text;
            return JsxRuntime.jsxs("li", {
              ref: (function (el) {
                if (isFocused) {
                  focusedEl.current = el;
                  return;
                }
                
              }),
              children: [
                option.text,
                isSelected ? JsxRuntime.jsx(Images__Icons.Checkmark.make, {
                    className: "Select-optionIcon"
                  }) : null
              ],
              "aria-selected": isSelected ? true : false,
              className: Css.merge([
                "Select-option",
                isFocused ? "is-focused" : "",
                isSelected ? "is-selected" : "",
                isDisabled ? "is-disabled" : ""
              ]),
              id: id,
              role: "option",
              onClick: (function (param) {
                handleChange(option);
              }),
              onMouseOver: (function (param) {
                Curry._1(setFocusedOption, (function (param) {
                  return [
                    index,
                    option
                  ];
                }));
              })
            }, Key);
          }),
          "aria-activedescendant": Stdlib__Option.value(Stdlib__Option.map((function (param) {
            return name + ("-" + param[1].text);
          }), focusedOption), ""),
          "aria-labelledby": "Select-label",
          className: Css.merge([
            "Select-optionList",
            Stdlib__Option.value(isOpen, false) ? "" : "is-hidden"
          ]),
          role: "listbox",
          tabIndex: -1,
          onKeyDown: handleListKeyDown,
          onFocus: handleListFocus
        }),
        className: "Select-optionListWrapper"
      })
    ],
    className: Css.merge([
      "Select",
      disabled ? "is-disabled" : "",
      Stdlib__Option.value(isOpen, false) ? "is-open" : "",
      className
    ])
  });
}

const Multi = {
  make: Select$Multi
};

export {
  css,
  SelectOption,
  Helpers,
  Single,
  Multi,
}
/* css Not a pure module */
